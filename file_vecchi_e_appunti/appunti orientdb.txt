##### Installazione su Ubuntu
http://www.famvdploeg.com/blog/2013/01/setting-up-an-orientdb-server-on-ubuntu/
%	Il pacchetto va scaricato manualmente dal sito e poi si può continuare come da tutorial (ovviamente attenzione al diverso nome del file zip!)
http://www.orientechnologies.com/docs/last/orientdb.wiki # wiki con i comandi sintetizzati qui sotto

##### AVVIO CONSOLE

sudo -u orientdb /opt/orientdb/bin/console.sh 
%	Come scritto nell'ultimo commento da me, altrimenti dà errore di negazione accesso (se eseguo il comando da utente normale)

##### CONNESSIONE AD UN DB

orientdb> connect remote:localhost root 061288 # connettiti a localhost con user e pass
orientdb> list databases # elenca i db installati
connect remote:localhost/GratefulDeadConcerts root 061288 # connettiti al database con user e pass

##### CLASSI ( più o meno come i record per i DBRMS)

%	Una classe (=documento) ha più attributi, come i record hanno più attributi. Il senso è quello...

classes # elenca le classi presenti
create class Student #crea una nuova classe
create property Student.name string # aggiungiamo un attributo (con tipo a fianco)
drop property Student.birthdate # cancelliamo un attributo
alter property Student.name min 3 # aggiungi vincolo ad un attributo
browse class OUser # elenca i records di una classe (di default mostra i primi 20)
display record 0 # mostra il record il cui ID è 0

##### CLUSTERS ( più o meno come le tabelle per i DBRMS)

%	Di default, viene creato un cluster per classe e in ogni cluster ci sono tutti i record della stessa classe.
%	Però una classe può appoggiarsi su due clusters: per esempio la classe Clienti che si poggia sui due clusters "Clienti Americani" e "Clienti Europei". Uno dei due viene scelto come cluster di default (per esempio quando devo inserire nuovi elementi). Quando voglio elencare tutti gli elementi di una classe, tutti i clusters relativi sono interrogati.

insert into Clienti ...
select * from Clienti
select * from cluster:Clienti_Americani # interrogazione diretta di un cluster (evito di fare lo scan di tutti e quindi velocizzo)

ALTER CLASS Clienti ADDCLUSTER Clienti_Italiani # aggiungo un cluster
ALTER CLASS Clienti REMOVECLUSTER CLienti_Italiani # levo un cluster

%	Cluster LOCALI: sono quelli memorizzati nel file system (scelta di default di OrientDB)
%	Cluster MEMORY: scritti in RAM

clusters # visualizzo tutti i clusters
browser cluster 0User # posso vedere i cluster associati ad una classe (almeno uno di default ci sarà)

###### RECORD ID (RID)

%	È l'indirizzo fisico di un record dentro il DB

load record RID # carica direttamente il record

##### SQL

select from cluster:OUser # seleziono un cluster
select from #10:3 # seleziono un RID
select from [#10:1, #10:3, #10:5] # seleziono più RIDs
select value from index:dictionary where key='Jay' # seleziono un indice

select from OUser where name like 'I%' # seleziono tutti i record di tipo OUser il cui nome comincia per I
select from Employee where city = 'Rome' order by surname asc, name asc # supporta l'ordering!

%	returns the sum of the salaries of all the employees with age under 40 grouped by job type:
select sum(salary) from Employee where age < 40 group by job 

%	seleziona gli impiegati maschi, filtrando per 20 risultati
select from Employee where gender = 'male' limit 20

%	paginazione dei risultati (come prima, a 20 a 20)
select from Employee where gender = 'male' limit 20
select from Employee where gender = 'male' skip 20 limit 20
select from Employee where gender = 'male' skip 40 limit 20

%	inserimento (due istruzioni che fanno la stessa cosa)
insert into Employee (name, surname, gender) values ('Jay', 'Miner', 'M') # standard
insert into Employee set name = 'Jay', surname = 'Miner', gender = 'M' # semplificato
insert into Employee content {name : 'Jay', surname : 'Miner', gender : 'M'} # per dati JSON

%	aggiornamento/modifica

update Employee set local = true where city = 'London' # standard

%	merging dei dati: uniamo le nuove informazioni alle vecchie:
update Employee merge { local : true } where city = 'London' # JSON

%	delete dei dati

delete from Employee where city <> 'London' # standard


##### RELATIONSHIP (parliamo di un DB a grafi!)

%	al posto dei JOIN, useremo i LINK
%	usano gli RID come se fossero dei puntatori nel linguaggio C

LINK # un record solo
LINKSET # vari record (senza ordinamento, un RID non può comparire due volte)
LINKLIST # vari record (in ordine, un RID può comparire più volte)
LINKMAP # vari record con una chiave memorizzata nel record sorgente. I valori MAP sono i vari RIDs.

##### GRAFI
create vertex V set name='Jay' # creo vertice
create class Person extends V # creo una nuova classe di vertici
create vertex Person set name='Luca' # creo un nuovo vertice di classe Person
create class Eat extends E # creiamo una nuova classe di archi (sono orientati !!!)
create edge Eat from (select from Person where name='Luca') to (select from Restaurant where name='Dante')
create edge from RID to RID # come prima se conosciamo gli RID
create edge Eat from (select from Person where name='Luca') to (select from Restaurant where name='Dante')

%	To know all the people who eat in the "Dante" restaurant, we can get Dante's record and then traverse 
%	the incoming edges to discover the Person records connected:

select in() from Restaurant where name = 'Dante' # elenca solo i RID e le loro connessioni
select expand( in() ) from Restaurant where name = 'Dante' # aggiunge agli RID i loro attributi

%	creo un arco 'amicizia' da Luca a Bill
select edge Friend from (select from Person where name='Luca') to (select from Person where name='Bill')


%	Get all the restaurants where Luca's friends go.

select expand( both('Friend').out('Eat') ) from Person where name = 'Luca'

%	lightweight edges: archi senza attributi, esistono solo come link da vertice a vertice
%	regular edges: esistono dentro E, sono archi con attributi

% disabilitiamo d'ora in poi l'uso degli archi leggeri: mi serve per poter elencare anche archi senza attributi
ALTER DATABASE CUSTOM useLightweightEdges=false
